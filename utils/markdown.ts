import { MarkdownSegment, PresentationData, WordData, ExcelData } from '../types';

/**
 * Parses a markdown string into an array of structured segments (paragraphs and code blocks).
 * Now supports filenames in code blocks, e.g., ```javascript:main.js
 * @param markdownText The raw markdown string from the AI.
 * @returns An array of MarkdownSegment objects.
 */
export function parseMarkdown(markdownText: string): MarkdownSegment[] {
    if (!markdownText) return [];

    const segments: MarkdownSegment[] = [];
    // Regex to capture language, optional filename, and code content
    const codeBlockRegex = /```(\w+)?(?::([\w.-]+))?\n([\s\S]*?)\n```/g;
    
    let lastIndex = 0;
    let match;

    while ((match = codeBlockRegex.exec(markdownText)) !== null) {
        // Add the text before the code block as a paragraph
        if (match.index > lastIndex) {
            const textContent = markdownText.substring(lastIndex, match.index).trim();
            if (textContent) {
                segments.push({ type: 'paragraph', content: textContent });
            }
        }

        // Add the code block
        segments.push({
            type: 'code',
            language: match[1] || 'plaintext',
            filename: match[2], // The new filename capture group
            content: match[3].trim(),
        });
        
        lastIndex = codeBlockRegex.lastIndex;
    }

    // Add any remaining text after the last code block
    if (lastIndex < markdownText.length) {
        const remainingText = markdownText.substring(lastIndex).trim();
        if (remainingText) {
            segments.push({ type: 'paragraph', content: remainingText });
        }
    }

    return segments;
}


/**
 * Renders paragraph content, handling headings, lists, bold, italics, and horizontal rules.
 * @param paragraphContent The content of a 'paragraph' segment.
 * @returns An HTML string.
 */
export function renderParagraph(paragraphContent: string): string {
     let html = paragraphContent
        .replace(/^###\s*(.*)/gm, '<h4>$1</h4>') // Use a placeholder
        .replace(/^\s*---\s*$/gm, '<hr />') // Use a placeholder for HR
        .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
        .replace(/\*(.*?)\*/g, '<em>$1</em>');
        
    const blocks = html.split(/\n\s*\n/).map(block => {
        let segment = block.trim();
        if (segment.length === 0) return '';

        // Render placeholders with styles
        if (segment.startsWith('<h4>')) {
            return segment.replace(/<h4>(.*?)<\/h4>/g, '<h4 class="text-amber-400 font-bold mt-4 mb-2 text-lg">$1</h4>');
        }
        if (segment.startsWith('<hr />')) {
            return '<hr class="border-gray-700 my-4">';
        }

        // Check for lists
        const isList = segment.match(/^(\d+\.|-|\*)\s/);
        if (isList) {
             const listHtml = segment.split('\n')
                .filter(line => line.trim().match(/^(\d+\.|-|\*)\s/))
                .map(item => `<li>${item.replace(/^(\d+\.|-|\*)\s/, '').trim()}</li>`)
                .join('');
             return `<ul class="space-y-1 pl-5 list-disc">${listHtml}</ul>`;
        }
        
        // Render standard paragraph
        return `<p>${segment.replace(/\n/g, '<br>')}</p>`;
    }).join('');
    
    return blocks;
}

// --- FILE GENERATION UTILITIES ---

const AIKON_PRIMARY_COLOR = 'FFC107';
const AIKON_TEXT_COLOR = 'F3F3F3';
const AIKON_BG_COLOR = '111111';

export const createPptxFile = async (data: PresentationData, topic: string): Promise<void> => {
    try {
        const pptx = new PptxGenJS();

        pptx.layout = '16x9';

        // Define Master Slide
        pptx.defineSlideMaster({
            title: 'AIKON_MASTER',
            background: { color: AIKON_BG_COLOR },
            objects: [
                { 'text': {
                    text: 'Aikon Studios | Generated by AikonAI',
                    options: { x: 0.5, y: 5.2, w: '90%', h: 0.25, fontFace: 'Inter', fontSize: 10, color: 'A9A9A9', align: 'center' }
                }},
                { 'placeholder': {
                    options: { name: 'body', type: 'body', x: 0.5, y: 1.5, w: '90%', h: 3.5, fontFace: 'Inter', fontSize: 16, color: AIKON_TEXT_COLOR, bullet: true },
                    text: '(Content)'
                }}
            ],
            slideNumber: { x: 9.5, y: 5.3, fontFace: 'Inter', fontSize: 10, color: 'A9A9A9' },
        });

        // Title Slide
        const titleSlide = pptx.addSlide();
        titleSlide.background = { color: AIKON_BG_COLOR };
        titleSlide.addText(topic, {
            x: 0.5, y: 2, w: '90%', h: 1,
            fontFace: 'Inter', fontSize: 44, bold: true, color: AIKON_PRIMARY_COLOR, align: 'center'
        });
        titleSlide.addText(`A presentation by Aikon Studios`, {
            x: 0.5, y: 3.2, w: '90%', h: 0.5,
            fontFace: 'Inter', fontSize: 18, color: AIKON_TEXT_COLOR, align: 'center'
        });

        // Content Slides
        for (const slideData of data.slides) {
            const slide = pptx.addSlide({ masterName: 'AIKON_MASTER' });
            slide.addText(slideData.title, {
                x: 0.5, y: 0.5, w: '90%', h: 0.75,
                fontFace: 'Inter', fontSize: 28, bold: true, color: AIKON_PRIMARY_COLOR
            });
            slide.addText(slideData.content.join('\n'), { placeholder: 'body' });
            if (slideData.speakerNotes) {
                slide.addNotes(slideData.speakerNotes);
            }
        }

        // Use the library's built-in `writeFile` method as it's the most direct way to trigger a download
        // and is more reliable for this specific library than the manual blob creation method.
        await pptx.writeFile({ fileName: `${topic.replace(/ /g, '_')}.pptx` });

    } catch (error) {
        console.error("Error generating PPTX file:", error);
        alert("An error occurred while generating the presentation. Please check the console for more details.");
    }
};

export const createDocxFile = async (data: WordData): Promise<void> => {
    const { Packer, Document, Paragraph, TextRun, HeadingLevel } = docx;

    const doc = new Document({
        styles: {
            paragraphStyles: [
                { id: "Heading1", name: "Heading 1", basedOn: "Normal", next: "Normal", quickFormat: true, run: { size: 32, bold: true, color: AIKON_PRIMARY_COLOR } },
                { id: "Heading2", name: "Heading 2", basedOn: "Normal", next: "Normal", quickFormat: true, run: { size: 24, bold: true, color: "000000" } }, // Black for contrast on white
                { id: "Normal", name: "Normal", basedOn: "Normal", next: "Normal", quickFormat: true, run: { size: 22, color: "333333" } },
            ],
        },
        sections: [{
            children: [
                new Paragraph({ text: data.title, heading: HeadingLevel.TITLE, alignment: 'center' }),
                new Paragraph({ text: "" }), // Spacer
                ...data.sections.flatMap(section => [
                    new Paragraph({ text: section.title, heading: HeadingLevel.HEADING_2 }),
                    ...section.content.split('\n').filter(p => p.trim()).map(p => new Paragraph({ text: p, style: "Normal" })),
                    new Paragraph({ text: "" }) // Spacer
                ])
            ],
        }],
    });
    
    const blob = await Packer.toBlob(doc);
    const url = window.URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = `${data.title.replace(/ /g, '_')}.docx`;
    document.body.appendChild(a);
    a.click();
    window.URL.revokeObjectURL(url);
    document.body.removeChild(a);
};

export const createXlsxFile = async (data: ExcelData): Promise<void> => {
    const workbook = new ExcelJS.Workbook();
    workbook.creator = 'AikonAI';
    workbook.created = new Date();

    for (const sheetData of data.sheets) {
        const worksheet = workbook.addWorksheet(sheetData.sheetName);
        
        const headerRow = worksheet.addRow(sheetData.headers);
        headerRow.eachCell((cell) => {
            cell.fill = {
                type: 'pattern',
                pattern: 'solid',
                fgColor: { argb: AIKON_PRIMARY_COLOR },
            };
            cell.font = {
                bold: true,
                color: { argb: '000000' }
            };
            cell.border = {
                bottom: { style: 'thin', color: { argb: '000000' } }
            };
        });

        worksheet.addRows(sheetData.rows);
        
        worksheet.columns.forEach(column => {
            if (!column.values) return;
            let maxLength = 0;
            column.values.forEach(value => {
                 let columnLength = value ? value.toString().length : 10;
                if (columnLength > maxLength) {
                    maxLength = columnLength;
                }
            });
            column.width = maxLength < 10 ? 10 : maxLength + 2;
        });
    }

    const buffer = await workbook.xlsx.writeBuffer();
    const blob = new Blob([buffer], { type: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet" });
    const url = window.URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = `${data.filename}.xlsx`;
    document.body.appendChild(a);
    a.click();
    window.URL.revokeObjectURL(url);
    document.body.removeChild(a);
};

export const createPdfFile = async (data: WordData): Promise<void> => {
    try {
        // The jspdf library is loaded via CDN and available on the window object.
        const { jsPDF } = jspdf;
        const doc = new jsPDF({
            orientation: 'p',
            unit: 'mm',
            format: 'a4'
        });

        const pageHeight = doc.internal.pageSize.getHeight();
        const pageWidth = doc.internal.pageSize.getWidth();
        const margin = 15;
        const maxLineWidth = pageWidth - margin * 2;
        let y = 25; // Initial Y position

        const addPageIfNeeded = (requiredHeight: number) => {
            if (y + requiredHeight > pageHeight - margin) {
                doc.addPage();
                y = 20; // Y position on new page
            }
        };
        
        // Document Title
        doc.setFont('helvetica', 'bold');
        doc.setFontSize(22);
        doc.text(data.title, pageWidth / 2, y, { align: 'center' });
        y += 20;

        // Sections
        for (const section of data.sections) {
            addPageIfNeeded(20); // Space for heading + some content

            // Section Title
            doc.setFont('helvetica', 'bold');
            doc.setFontSize(16);
            doc.text(section.title, margin, y);
            y += 10;
            
            // Section Content
            doc.setFont('helvetica', 'normal');
            doc.setFontSize(12);

            // Split text to fit within page width
            const splitContent = doc.splitTextToSize(section.content, maxLineWidth);

            for (const line of splitContent) {
                addPageIfNeeded(7); // Approximate height of a line
                doc.text(line, margin, y);
                y += 7; // Line height
            }
            y += 10; // Space after section
        }

        doc.save(`${data.title.replace(/ /g, '_')}.pdf`);

    } catch (error) {
        console.error("Error generating PDF file:", error);
        alert("An error occurred while generating the PDF. Please check the console for more details.");
    }
};